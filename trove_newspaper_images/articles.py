# AUTOGENERATED! DO NOT EDIT! File to edit: 00_articles.ipynb (unless otherwise specified).

__all__ = ['get_box', 'get_article_boxes', 'download_images']

# Cell

import requests
from bs4 import BeautifulSoup
from PIL import Image
from io import BytesIO
import re
from pathlib import Path
from fastcore.script import *

def get_box(zones):
    '''
    Loop through all the zones to find the outer limits of each boundary.
    Return a bounding box around the article.
    '''
    # Set a left value larger than the image width
    left = 10000
    right = 0
    # Set a top value larger than the image height
    top = 10000
    bottom = 0
    # Get the page identifier
    page_id = zones[0]['data-page-id']

    # Loop through zones to find the outer boundaries of the article
    for zone in zones:
        if int(zone['data-y']) < top:
            top = int(zone['data-y'])
        if int(zone['data-x']) < left:
            left = int(zone['data-x'])
        if (int(zone['data-x']) + int(zone['data-w'])) > right:
            right = int(zone['data-x']) + int(zone['data-w'])
        if (int(zone['data-y']) + int(zone['data-h'])) > bottom:
            bottom = int(zone['data-y']) + int(zone['data-h'])
    return {'page_id': page_id, 'left': left, 'top': top, 'right': right, 'bottom': bottom}

def get_article_boxes(article_id):
    '''
    Get a list of boundary boxes for an article, each box representing the position of an article on a page.

    Positional information about the article is attached to each line of the OCR output in data attributes.

    This function loads the HTML version of the article and scrapes the x, y, and width values for each line of text
    to determine the coordinates of a box around the article.
    '''
    boxes = []
    response = requests.get(f'https://trove.nla.gov.au/newspaper/article/{article_id}')
    soup = BeautifulSoup(response.text, 'lxml')

    # Lines of OCR are in divs with the class 'zone'
    # Zones with the class 'onPage' are those on those on the current page

    # Get the 'onPage' zones.
    zones = soup.select('div.zone.onPage')

    # Get the article bounding box for this page.
    boxes.append(get_box(zones))

    # If the article is split over multiple pages there will be zones with the class 'offPage'.
    # These zones include the id of additional pages and the coords of text within them.
    # We need to process these zones to get all the parts of an article across multiple pages.

    # Get all the offPage zones
    off_page_zones = soup.select('div.zone.offPage')
    if off_page_zones:

        # Get the page id of the first additional page
        current_page = off_page_zones[0]['data-page-id']
        zones = []

        # Loop through all the zones
        for zone in off_page_zones:

            # If this zone has the id of the current page, append this zone to the current zones
            if zone['data-page-id'] == current_page:
                zones.append(zone)

            # If not, process the list of zones and then start a new one for the next page
            else:
                # Get the article boundary box for this page and add it to the list of boxes
                boxes.append(get_box(zones))
                zones = [zone]

                # Set the current_page to the new page id
                current_page = zone['data-page-id']

        # Get the article boundary box for this page and add it to the list of boxes
        boxes.append(get_box(zones))
    return boxes

# This decorator calls fastcore.script to help turn this function into a command line script
@call_parse
def download_images(article_id:Param('Article identifier', str), output_dir:Param('Output directory', str)='', size:Param('Max image dimensions', int)=None):
    '''
    Extract an image of a newspaper article from the page image(s), download and save it, and return the image filename(s).

    Parameters:

    * article_id -- identifier for a Trove newspaper article
    * output_dir -- a directory to save images in (will be created if it doesn't exist)

    Returns:

    * a list of image file names
    '''
    images = []
    # Get position of article on the page(s)
    boxes = get_article_boxes(article_id)
    for box in boxes:

        # Construct the url we need to download the full page image
        page_url = f'https://trove.nla.gov.au/ndp/imageservice/nla.news-page{box["page_id"]}/level7'

        # Download the page image
        response = requests.get(page_url)

        # Open download as an image for editing
        img = Image.open(BytesIO(response.content))

        # Use coordinates of the bounding box to crop article
        points = (box['left'], box['top'], box['right'], box['bottom'])

        # Crop image to article box
        cropped = img.crop(points)

        # Resize if necessary
        if size:
            cropped.thumbnail((size, size), Image.LANCZOS)

        # Save cropped image
        if output_dir:
            output_path = Path(output_dir)
            output_path.mkdir(exist_ok=True, parents=True)
        else:
            output_path = ''
        cropped_file = Path(output_path, f'nla.news-article{article_id}-{box["page_id"]}.jpg')
        cropped.save(cropped_file)
        images.append(cropped_file.name)
    print(f'Downloaded: {images}')
    return images